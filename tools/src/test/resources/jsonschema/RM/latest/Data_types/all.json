{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/RM/latest/Data_types/all.json",
    "title": "Data_types IM definitions",
    "description": "A set of clearly defined data types underlies all other models, and provides a number of general and clinically specific types required for all kinds of health information. The following categories of data types are defined in the data types reference model. \n- Text: plain text, coded text, paragraphs. \n- Quantities: any ordered type including ordinal values (used for representing symbolic ordered \n  values such as  + ,  ++ ,  +++ ), measured quantities with values and units, and so on. \n- Date/times: date, time, date-time types, and partial date/time types. \n- Encapsulated data: multimedia, parsable content. \n- Basic types: boolean, state variable. \n",
    "definitions": {
        "DATA_VALUE": {
            "title": "DATA_VALUE",
            "description": "Abstract parent of all `DV_` data value types.",
            "$comments": "Defined in Data_types IM, abstract",
            "type": "object"
        },
        "DV_BOOLEAN": {
            "title": "DV_BOOLEAN",
            "description": "Items which are truly boolean data, such as true/false or yes/no answers. For such data, it is important to devise the meanings (usually questions in subjective data)  carefully, so that the only allowed results are in fact true or false. \n\nMisuse: The DV_BOOLEAN class should not be used as a replacement for naively modelled enumerated types such as male/female etc. Such values should be coded, and in any case the enumeration often has more than two values. \n",
            "$comments": "Defined in Data_types IM, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "value": {
                    "description": "Boolean value of this item. Actual values may be language or implementation dependent.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ]
        },
        "DV_STATE": {
            "title": "DV_STATE",
            "description": "For representing state values which obey a defined state machine, such as a variable  representing the states of an instruction or care process. \n\nDV_STATE is expressed as a String but its values are driven by archetype-defined  state machines. This provides a powerful way of capturing stateful complex processes  in simple data. \n",
            "$comments": "Defined in Data_types IM, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "value": {
                    "description": "The state name. State names are determined by a state/event table defined in archetypes, and coded using openEHR Terminology or local archetype terms, as specified by the archetype. ",
                    "$ref": "#/definitions/DV_CODED_TEXT"
                },
                "is_terminal": {
                    "description": "Indicates whether this state is a terminal state, such as  \"aborted\",  \"completed\" etc. from which no further transitions are possible.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                }
            },
            "required": [
                "value",
                "is_terminal"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ]
        },
        "DV_IDENTIFIER": {
            "title": "DV_IDENTIFIER",
            "description": "Type for representing identifiers of real-world entities. Typical identifiers include drivers licence number, social security number, veterans affairs number, prescription id, order id, and so on.\n\nDV_IDENTIFIER is used to represent any identifier of a real thing, issued by some authority or agency. \n\nMisuse: DV_IDENTIFIER is not used to express identifiers generated by the infrastructure to refer to information items; the types OBJECT_ID and OBJECT_REF and subtypes are defined for this purpose.",
            "$comments": "Defined in Data_types IM, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "issuer": {
                    "description": "Optional authority which issues the kind of id used in the id field of this object. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "assigner": {
                    "description": "Optional organisation that assigned the id to the item being identified.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "id": {
                    "description": "The identifier value. Often structured, according to the definition of the issuing authority's rules. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "type": {
                    "description": "Optional identifier type, such as  prescription , or  Social Security Number . One day a controlled vocabulary might be possible for this.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                }
            },
            "required": [
                "id"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ],
            "$invariants": {
                "Issuer_valid": {
                    "description": "not issuer.is_empty"
                },
                "Assigner_valid": {
                    "description": "not assigner.is_empty"
                },
                "Id_valid": {
                    "description": "not id.is_empty"
                },
                "Type_valid": {
                    "description": "not type.is_empty"
                }
            }
        },
        "DV_ENCAPSULATED": {
            "title": "DV_ENCAPSULATED",
            "description": "Abstract class defining the common meta-data of all types of encapsulated data.",
            "$comments": "Defined in Data_types IM, abstract, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "charset": {
                    "description": "Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "language": {
                    "description": "Optional indicator of the localised language in which the data is written, if relevant. Coded from openEHR Code Set `languages`.",
                    "$ref": "#/definitions/CODE_PHRASE"
                }
            },
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ],
            "$invariants": {
                "Size_valid": {
                    "description": "size >= 0"
                },
                "Language_valid": {
                    "description": "language /= Void implies code_set (Code_set_id_languages).has_code (language)"
                },
                "Charset_valid": {
                    "description": "charset /= Void implies code_set (Code_set_id_character_sets).has_code (charset)"
                }
            }
        },
        "DV_MULTIMEDIA": {
            "title": "DV_MULTIMEDIA",
            "description": "A specialisation of `DV_ENCAPSULATED` for audiovisual and bio-signal types. Includes further metadata relating to multimedia types which are not applicable to other subtypes of `DV_ENCAPSULATED`.",
            "$comments": "Defined in Data_types IM, inherits from DV_ENCAPSULATED",
            "type": "object",
            "properties": {
                "charset": {
                    "description": "Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "language": {
                    "description": "Optional indicator of the localised language in which the data is written, if relevant. Coded from openEHR Code Set `languages`.",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "alternate_text": {
                    "description": "Text to display in lieu of multimedia display/replay.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "uri": {
                    "description": "URI reference to electronic information stored outside the record as a file, database entry etc, if supplied as a reference. \n",
                    "$ref": "#/definitions/DV_URI"
                },
                "data": {
                    "description": "The actual data found at `_uri_`, if supplied inline.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Character"
                },
                "media_type": {
                    "description": "Data media type coded from openEHR code set  media types  (interface for the IANA MIME types code set). \n",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "compression_algorithm": {
                    "description": "Compression type, a coded value from the openEHR Integrity check code set. Void means no compression. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "integrity_check": {
                    "description": "Binary cryptographic integrity checksum.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Character"
                },
                "integrity_check_algorithm": {
                    "description": "Type of integrity check, a coded value from the openEHR `Integrity check` code set. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "thumbnail": {
                    "description": "The thumbnail for this item, if one exists; mainly for graphics formats.",
                    "$ref": "#/definitions/DV_MULTIMEDIA"
                },
                "size": {
                    "description": "Original size in bytes of unencoded encapsulated data. I.e. encodings such as base64, hexadecimal etc do not change the value of this attribute.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Integer"
                }
            },
            "required": [
                "media_type",
                "size"
            ],
            "$inherits": [
                "#/definitions/DV_ENCAPSULATED"
            ],
            "$functions": {
                "is_external": {
                    "description": "Computed from the value of the `_uri_` attribute: True if  the data is stored externally to the record, as indicated by `_uri_`. A copy may also be stored internally, in which case `_is_expanded_` is also true."
                },
                "is_inline": {
                    "description": "Computed from the value of the data attribute. True if  the  data is stored  in  expanded  form, ie within the EHR itself. "
                },
                "is_compressed": {
                    "description": "Computed from the value of the `_compression_algorithm_` attribute: True if  the  data is stored in compressed form. "
                },
                "has_integrity_check": {
                    "description": "Computed from the value of the `_integrity_check_algorithm_` attribute: True if an integrity check has been computed. "
                }
            },
            "$invariants": {
                "Size_valid": {
                    "description": "size >= 0"
                },
                "Language_valid": {
                    "description": "language /= Void implies code_set (Code_set_id_languages).has_code (language)"
                },
                "Charset_valid": {
                    "description": "charset /= Void implies code_set (Code_set_id_character_sets).has_code (charset)"
                },
                "Not_empty": {
                    "description": "is_inline or is_external"
                },
                "Media_type_valid": {
                    "description": "media_type /= Void and then code_set (Code_set_id_media_types).has_code (media_type)"
                },
                "Compression_algorithm_validity": {
                    "description": "compression_algorithm /= Void implies code_set (Code_set_id_compression_algorithms).has_code (compression_algorithm)"
                },
                "Integrity_check_validity": {
                    "description": "integrity_check /= Void implies integrity_check_algorithm /= Void"
                },
                "Integrity_check_algorithm_validity": {
                    "description": "integrity_check_algorithm /= Void implies code_set (Code_set_id_integrity_check_algorithms).has_code (integrity_check_algorithm)"
                }
            }
        },
        "DV_PARSABLE": {
            "title": "DV_PARSABLE",
            "description": "Encapsulated data expressed as a parsable String. The internal model of the data item is not described in the openEHR model in common with other encapsulated types, but in this case, the form of the data is assumed to be plaintext, rather than compressed or other types of large binary data. ",
            "$comments": "Defined in Data_types IM, inherits from DV_ENCAPSULATED",
            "type": "object",
            "properties": {
                "charset": {
                    "description": "Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "language": {
                    "description": "Optional indicator of the localised language in which the data is written, if relevant. Coded from openEHR Code Set `languages`.",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "value": {
                    "description": "The string, which may validly be empty in some syntaxes.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "formalism": {
                    "description": "Name of the formalism, e.g.  GLIF 1.0 ,  Proforma  etc.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                }
            },
            "required": [
                "value",
                "formalism"
            ],
            "$inherits": [
                "#/definitions/DV_ENCAPSULATED"
            ],
            "$functions": {
                "size": {
                    "description": "Size in bytes of value."
                }
            },
            "$invariants": {
                "Size_valid": {
                    "description": "size >= 0"
                },
                "Language_valid": {
                    "description": "language /= Void implies code_set (Code_set_id_languages).has_code (language)"
                },
                "Charset_valid": {
                    "description": "charset /= Void implies code_set (Code_set_id_character_sets).has_code (charset)"
                },
                "Formalism_valid": {
                    "description": "not formalism.is_empty"
                }
            }
        },
        "DV_PARAGRAPH": {
            "title": "DV_PARAGRAPH",
            "description": "A logical composite text value consisting of a series of `DV_TEXTs`, i.e. plain text (optionally coded) potentially with simple formatting, to form a larger tract of prose, which may be interpreted for display purposes as a paragraph. \n\n`DV_PARAGRAPH` is the standard way for constructing longer text items in summaries, reports and so on. ",
            "$comments": "Defined in Data_types IM, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "items": {
                    "description": "Items making up the paragraph, each of which is a text item (which may have its own formatting, and/or have hyperlinks). ",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/DV_TEXT"
                    },
                    "minItems": 1
                }
            },
            "required": [
                "items"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ],
            "$invariants": {
                "Items_valid": {
                    "description": "not items.is_empty"
                }
            }
        },
        "DV_TEXT": {
            "title": "DV_TEXT",
            "description": "A text item, which may contain any amount of legal characters arranged as e.g. words, sentences etc (i.e. one `DV_TEXT` may be more than one word). Visual formatting and hyperlinks may be included. \n\nA `DV_TEXT` can be  coded  by adding mappings to it. \n\nFragments of text, whether coded or not are used on their own as values, or to make up larger tracts of text which may be marked up in some way, eventually going to make up paragraphs.",
            "$comments": "Defined in Data_types IM, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "value": {
                    "description": "Displayable rendition of the item, regardless of its underlying structure. For `DV_CODED_TEXT`, this is the rubric of the complete term as provided by the terminology service. No carriage returns, line feeds, or other non-printing characters permitted. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "hyperlink": {
                    "description": "Optional link sitting behind a section of plain text or coded term item. ",
                    "$ref": "#/definitions/DV_URI"
                },
                "formatting": {
                    "description": "A format string of the form `\"name:value; name:value...\"` , e.g. `\"font-weight : bold; font-family : Arial; font-size : 12pt;\"`. \n\nValues taken from W3C CSS2 properties lists  back-ground and font . ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "mappings": {
                    "description": "Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC). \n",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/TERM_MAPPING"
                    }
                },
                "language": {
                    "description": "Optional indicator of the localised language in which the value is written. Coded from openEHR Code Set  languages . Only used when either the text object is in a different language from the enclosing `ENTRY`, or else the text object is being used outside of an `ENTRY` or other enclosing structure which indicates the language. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "encoding": {
                    "description": "Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions. \n",
                    "$ref": "#/definitions/CODE_PHRASE"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ],
            "$invariants": {
                "Valid_value": {
                    "description": "not value.is_empty and then not (value.has(CR) or value.has(LF))"
                },
                "Language_valid": {
                    "description": "language /= Void implies code_set (Code_set_id_languages).has_code (language)"
                },
                "Encoding_valid": {
                    "description": "encoding /= Void implies code_set (Code_set_id_character_sets).has_code (encoding)"
                },
                "Mappings_valid": {
                    "description": "mappings /= void implies not mappings.is_empty"
                },
                "Formatting_valid": {
                    "description": "formatting /= void implies not formatting.is_empty"
                }
            }
        },
        "DV_CODED_TEXT": {
            "title": "DV_CODED_TEXT",
            "description": "A text item whose value must be the rubric from a controlled terminology, the key (i.e. the 'code') of which is the `_defining_code_` attribute. In other words: a `DV_CODED_TEXT` is a combination of a `CODE_PHRASE` (effectively a code) and the rubric of that term, from a terminology service, in the language in which the data were authored. \n\nSince `DV_CODED_TEXT` is a subtype of `DV_TEXT`, it can be used in place of it, effectively allowing the type `DV_TEXT` to mean  a text item, which may optionally be coded. \n\nMisuse: If the intention is to represent a term code attached in some way to a fragment of plain text, `DV_CODED_TEXT` should not be used; instead use a `DV_TEXT` and a `TERM_MAPPING` to a `CODE_PHRASE`. ",
            "$comments": "Defined in Data_types IM, inherits from DV_TEXT",
            "type": "object",
            "properties": {
                "value": {
                    "description": "Displayable rendition of the item, regardless of its underlying structure. For `DV_CODED_TEXT`, this is the rubric of the complete term as provided by the terminology service. No carriage returns, line feeds, or other non-printing characters permitted. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "hyperlink": {
                    "description": "Optional link sitting behind a section of plain text or coded term item. ",
                    "$ref": "#/definitions/DV_URI"
                },
                "formatting": {
                    "description": "A format string of the form `\"name:value; name:value...\"` , e.g. `\"font-weight : bold; font-family : Arial; font-size : 12pt;\"`. \n\nValues taken from W3C CSS2 properties lists  back-ground and font . ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "mappings": {
                    "description": "Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC). \n",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/TERM_MAPPING"
                    }
                },
                "language": {
                    "description": "Optional indicator of the localised language in which the value is written. Coded from openEHR Code Set  languages . Only used when either the text object is in a different language from the enclosing `ENTRY`, or else the text object is being used outside of an `ENTRY` or other enclosing structure which indicates the language. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "encoding": {
                    "description": "Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions. \n",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "defining_code": {
                    "description": "The term of which the  `_value_` attribute is the textual rendition (i.e. rubric). \n",
                    "$ref": "#/definitions/CODE_PHRASE"
                }
            },
            "required": [
                "value",
                "defining_code"
            ],
            "$inherits": [
                "#/definitions/DV_TEXT"
            ],
            "$invariants": {
                "Valid_value": {
                    "description": "not value.is_empty and then not (value.has(CR) or value.has(LF))"
                },
                "Language_valid": {
                    "description": "language /= Void implies code_set (Code_set_id_languages).has_code (language)"
                },
                "Encoding_valid": {
                    "description": "encoding /= Void implies code_set (Code_set_id_character_sets).has_code (encoding)"
                },
                "Mappings_valid": {
                    "description": "mappings /= void implies not mappings.is_empty"
                },
                "Formatting_valid": {
                    "description": "formatting /= void implies not formatting.is_empty"
                }
            }
        },
        "TERM_MAPPING": {
            "title": "TERM_MAPPING",
            "description": "Represents a coded term mapped to a `DV_TEXT`, and the relative match of the target term with respect to the mapped item. Plain or coded text items may appear in the EHR for which one or mappings in alternative terminologies are required. Mappings are only used to enable computer processing, so they can only be instances of `DV_CODED_TEXT`.\n\nUsed for adding classification terms (e.g. adding ICD classifiers to SNOMED descriptive terms), or mapping into equivalents in other terminologies (e.g. across nursing vocabularies). \n",
            "$comments": "Defined in Data_types IM",
            "type": "object",
            "properties": {
                "match": {
                    "description": "The relative match of the target term with respect to the mapped text item. Result meanings: \n\n* `'>'`: the mapping is to a broader term e.g. orginal text =  arbovirus infection , target =  viral infection  \n* `'='`: the mapping is to a (supposedly) equivalent to the original item \n* `'<'`: the mapping is to a narrower term. e.g. original text =  diabetes , mapping =  diabetes mellitus . \n* `'?'`: the kind of mapping is unknown. \n\nThe first three values are taken from the ISO standards 2788 ( Guide to Establishment and development of monolingual thesauri) and 5964 (Guide to Establishment and development of multilingual thesauri). \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Character"
                },
                "purpose": {
                    "description": "Purpose of the mapping e.g. 'automated data mining', 'billing', 'interoperability'.",
                    "$ref": "#/definitions/DV_CODED_TEXT"
                },
                "target": {
                    "description": "The target term of the mapping. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                }
            },
            "required": [
                "match",
                "target"
            ],
            "$functions": {
                "narrower": {
                    "description": "The mapping is to a narrower term."
                },
                "broader": {
                    "description": "The mapping is to a broader term."
                },
                "equivalent": {
                    "description": "The mapping is to an equivalent term."
                },
                "unknown": {
                    "description": "The kind of mapping is unknown."
                },
                "is_valid_match_code": {
                    "description": "True if match valid."
                }
            },
            "$invariants": {
                "Purpose_valid": {
                    "description": "purpose /= Void implies terminology (Terminology_id_openehr).has_code_for_group_id (Group_id_term_mapping_purpose, purpose.defining_code)"
                },
                "Match_valid": {
                    "description": "is_valid_match_code (match)"
                },
                "Post": {
                    "description": "Result := c = \u2018>\u2019 or c = \u2018=\u2019 or c = \u2018<\u2019 or c = \u2018?\u2019"
                }
            }
        },
        "CODE_PHRASE": {
            "title": "CODE_PHRASE",
            "description": "A fully coordinated (i.e. all coordination has been performed) term from a terminology service (as distinct from a particular terminology). ",
            "$comments": "Defined in Data_types IM",
            "type": "object",
            "properties": {
                "terminology_id": {
                    "description": "Identifier of the distinct terminology from which the code_string (or its elements) was extracted.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Base_types/all.json#/definitions/TERMINOLOGY_ID"
                },
                "code_string": {
                    "description": "The key used by the terminology service to identify a concept or coordination of concepts. This string is most likely parsable inside the terminology service, but nothing can be assumed about its syntax outside that context. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                }
            },
            "required": [
                "terminology_id",
                "code_string"
            ],
            "$invariants": {
                "Code_string_valid": {
                    "description": "not code_string.is_empty"
                }
            }
        },
        "DV_ORDERED": {
            "title": "DV_ORDERED",
            "description": "Abstract class defining the concept of ordered values, which includes ordinals as well as true quantities. It defines the functions  `<` and is_strictly_comparable_to, the latter of which must evaluate to `True` for instances being compared with the  `<` function, or used as limits in the `DV_INTERVAL<T>` class. \n\nData value types which are to be used as limits in the `DV_INTERVAL<T>` class must inherit from this class, and implement the function `_is_strictly_comparable_to_` to ensure that instances compare meaningfully. For example, instances of `DV_QUANTITY` can only be compared if they measure the same kind of physical quantity. \n",
            "$comments": "Defined in Data_types IM, abstract, inherits from DATA_VALUE, Ordered",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                }
            },
            "$inherits": [
                "#/definitions/DATA_VALUE",
                "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Ordered"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                }
            }
        },
        "DV_INTERVAL": {
            "title": "DV_INTERVAL",
            "description": "Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, `T`, must be a descendant of the type `DV_ORDERED`, which is necessary (but not sufficient) for instances to be compared (`_strictly_comparable_` is also needed). \n\nWithout the `DV_INTERVAL` class, quite a few more `DV_` classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison. \n\nThe basic semantics are derived from the class `Interval<T>`, described in the support RM. ",
            "$comments": "Defined in Data_types IM, inherits from DATA_VALUE, Interval",
            "type": "object",
            "properties": {
                "lower": {
                    "description": "lower bound.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/RM/latest/Common/all.json#/definitions/T"
                },
                "lower_unbounded": {
                    "description": "lower boundary open (i.e. = -infinity)",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                },
                "upper_unbounded": {
                    "description": "upper boundary open (i.e. = +infinity)",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                },
                "lower_included": {
                    "description": "lower boundary value included in range if not lower_unbounded.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                },
                "upper_included": {
                    "description": "upper boundary value included in range if not upper_unbounded.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                }
            },
            "required": [
                "lower_unbounded",
                "upper_unbounded",
                "lower_included",
                "upper_included"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE",
                "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Interval"
            ],
            "$functions": {
                "has": {
                    "description": "True if (lower_unbounded or \n((lower_included and v >= lower) or \nv > lower)) and \n(upper_unbounded or \n((upper_included and v <= upper or v \n< upper)))"
                },
                "intersects": {
                    "description": "True if there is any overlap between intervals represented by Current and `other'. True if at least one limit of other is strictly inside the limits of this interval."
                },
                "contains": {
                    "description": "True if current interval properly contains `other'? True if all points of `other' are inside the current interval."
                },
                "is_equal": {
                    "description": "True if current object's interval is semantically same as `other'."
                },
                "upper": {
                    "description": null
                }
            },
            "$invariants": {
                "Lower_included_valid": {
                    "description": "lower_unbounded implies not lower_included"
                },
                "Upper_included_valid": {
                    "description": "upper_unbounded implies not upper_included"
                },
                "Limits_consistent": {
                    "description": "(not upper_unbounded and not lower_unbounded) implies (lower.is_strictly_comparable_to(upper) and lower <= upper)"
                },
                "Limits_comparable": {
                    "description": "(not upper_unbounded and not lower_unbounded) implies lower.strictly_comparable_to (upper)"
                }
            }
        },
        "REFERENCE_RANGE": {
            "title": "REFERENCE_RANGE",
            "description": "Defines a named range to be associated with any `DV_ORDERED` datum. Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. May be used to represent normal, therapeutic, dangerous, critical etc ranges.",
            "$comments": "Defined in Data_types IM",
            "type": "object",
            "properties": {
                "meaning": {
                    "description": "Term whose value indicates the meaning of this range, e.g.  normal,  critical,  therapeutic  etc.",
                    "$ref": "#/definitions/DV_TEXT"
                },
                "range": {
                    "description": "The data range for this meaning, e.g. critical  etc.",
                    "$ref": "#/definitions/DV_INTERVAL"
                }
            },
            "required": [
                "meaning",
                "range"
            ],
            "$functions": {
                "is_in_range": {
                    "description": "Indicates if the value  val' is inside the range.\n"
                }
            },
            "$invariants": {
                "Range_is_simple": {
                    "description": "(range.lower_unbounded or else range.lower.is_simple) and (range.upper_unbounded or else range.upper.is_simple)"
                }
            }
        },
        "DV_QUANTIFIED": {
            "title": "DV_QUANTIFIED",
            "description": "Abstract class defining the concept of true quantified values, i.e. values which are not only ordered, but which have a precise magnitude.",
            "$comments": "Defined in Data_types IM, abstract, inherits from DV_ORDERED",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Accuracy of measurement. Exact form of expression determined in descendants.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Any"
                }
            },
            "$inherits": [
                "#/definitions/DV_ORDERED"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": null
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                }
            }
        },
        "DV_PROPORTION": {
            "title": "DV_PROPORTION",
            "description": "Models a ratio of values, i.e. where the numerator and denominator are both pure numbers. The `_valid_proportion_kind_` property of the `PROPORTION_KIND` class is used to control the type attribute to be one of a defined set.\n\nUsed for recording titers (e.g. 1:128), concentration ratios, e.g. Na:K (unitary denominator), albumin:creatinine ratio, and percentages, e.g. red cell distirbution width (RDW). \n \nMisuse: Should not be used to represent things like blood pressure which are often written using a  '/' character, giving the misleading impression that the item is a ratio, when in fact it is a structured value. Similarly, visual acuity, often written as (e.g.) \"6/24\" in clinical notes is not a ratio but an ordinal (which includes non-numeric symbols like CF = count fingers etc). Should not be used for formulations. ",
            "$comments": "Defined in Data_types IM, inherits from PROPORTION_KIND, DV_AMOUNT",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL_of_DV_PROPORTION"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE_of_DV_PROPORTION"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Accuracy of measurement, expressed either as a half-range percent value (`_accuracy_is_percent_` = `True`) or a half-range quantity. A value of `0` means that accuracy is 100%, i.e. no error.\n\nA value of `_unknown_accuracy_value_` means that accuracy was not recorded.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "accuracy_is_percent": {
                    "description": "If `True`, indicates that when this object was created, accuracy was recorded as a percent value; if `False`, as an absolute quantity value.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                },
                "numerator": {
                    "description": "Numerator of ratio",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "denominator": {
                    "description": "Denominator of ratio.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "type": {
                    "description": "Indicates semantic type of proportion, including percent, unitary etc.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Integer"
                },
                "precision": {
                    "description": "Precision  to  which  the  numerator and denominator values of  the  proportion are expressed, in terms of number  of  decimal places. The value 0 implies an integral quantity. The value -1 implies no limit, i.e. any number of decimal places. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Integer"
                }
            },
            "required": [
                "numerator",
                "denominator",
                "type"
            ],
            "$inherits": [
                "#/definitions/PROPORTION_KIND",
                "#/definitions/DV_AMOUNT"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": "Effective magnitude represented by ratio."
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "valid_percentage": {
                    "description": "Test whether a number is a valid percentage, i.e. between 0 and 100. "
                },
                "infix =": {
                    "description": "Assignment operator"
                },
                "infix +": {
                    "description": "Sum of this quantity and another whose formal type must be the difference type of this quantity. The value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* both operand accuracies are unknown_accuracy_value.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "infix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "prefix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss."
                },
                "valid_proportion_kind": {
                    "description": "True if n is one of the defined types. "
                },
                "is_integral": {
                    "description": "True if the numerator and denominator values are integers, i.e. if the precision is 0."
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Accuracy_is_percent_validity": {
                    "description": "accuracy = 0 implies not accuracy_is_percent"
                },
                "Accuracy_validity": {
                    "description": "accuracy_is_percent implies valid_percentage (accuracy)"
                },
                "Type_validity": {
                    "description": "valid_proportion_kind (type)"
                },
                "Precision_validity": {
                    "description": "precision = 0 implies is_integral"
                },
                "Is_integral_validity": {
                    "description": "is_integral implies (numerator.floor = numerator and denominator.floor = denominator)"
                },
                "Fraction_validity": {
                    "description": "(type = pk_fraction or type = pk_integer_fraction) implies is_integral"
                },
                "Unitary_validity": {
                    "description": "type = pk_unitary implies denominator = 1"
                },
                "Percent_validity": {
                    "description": "type = pk_percent implies denominator = 100"
                },
                "Valid_denominator": {
                    "description": "denominator /= 0.0"
                }
            }
        },
        "PROPORTION_KIND": {
            "title": "PROPORTION_KIND",
            "description": "Class of enumeration constants defining types of proportion for the `DV_PROPORTION` class. ",
            "$comments": "Defined in Data_types IM",
            "type": "object",
            "$functions": {
                "valid_proportion_kind": {
                    "description": "True if n is one of the defined types. "
                }
            }
        },
        "DV_AMOUNT": {
            "title": "DV_AMOUNT",
            "description": "Abstract class defining the concept of relative quantified  'amounts'. For relative quantities, the  `+` and  `-` operators are defined (unlike descendants of `DV_ABSOLUTE_QUANTITY`, such as the date/time types). \n",
            "$comments": "Defined in Data_types IM, abstract, inherits from DV_QUANTIFIED",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Accuracy of measurement, expressed either as a half-range percent value (`_accuracy_is_percent_` = `True`) or a half-range quantity. A value of `0` means that accuracy is 100%, i.e. no error.\n\nA value of `_unknown_accuracy_value_` means that accuracy was not recorded.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "accuracy_is_percent": {
                    "description": "If `True`, indicates that when this object was created, accuracy was recorded as a percent value; if `False`, as an absolute quantity value.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                }
            },
            "$inherits": [
                "#/definitions/DV_QUANTIFIED"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": null
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "valid_percentage": {
                    "description": "Test whether a number is a valid percentage, i.e. between 0 and 100. "
                },
                "infix =": {
                    "description": null
                },
                "infix +": {
                    "description": "Sum of this quantity and another whose formal type must be the difference type of this quantity. The value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* both operand accuracies are unknown_accuracy_value.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "infix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "prefix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss."
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Accuracy_is_percent_validity": {
                    "description": "accuracy = 0 implies not accuracy_is_percent"
                },
                "Accuracy_validity": {
                    "description": "accuracy_is_percent implies valid_percentage (accuracy)"
                }
            }
        },
        "DV_QUANTITY": {
            "title": "DV_QUANTITY",
            "description": "Quantitified type representing  scientific  quantities, i.e. quantities expressed as a magnitude and units. Units were inspired by the http://unitsofmeasure.org/ucum.html[Unified Code for Units of Measure (UCUM)], developed by Gunther Schadow and Clement J. McDonald of The Regenstrief Institute. \n\nCan also be used for time durations, where it is more convenient to treat these as simply a number of seconds rather than days, months, years. ",
            "$comments": "Defined in Data_types IM, inherits from DV_AMOUNT",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL_of_DV_QUANTITY"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE_of_DV_QUANTITY"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Accuracy of measurement, expressed either as a half-range percent value (`_accuracy_is_percent_` = `True`) or a half-range quantity. A value of `0` means that accuracy is 100%, i.e. no error.\n\nA value of `_unknown_accuracy_value_` means that accuracy was not recorded.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "accuracy_is_percent": {
                    "description": "If `True`, indicates that when this object was created, accuracy was recorded as a percent value; if `False`, as an absolute quantity value.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                },
                "magnitude": {
                    "description": "Numeric magnitude of the quantity.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "precision": {
                    "description": "Precision to which the value of the quantity is expressed, in terms of number of decimal places. The value 0 implies an integral quantity.\nThe value -1 implies no limit, i.e. any number of decimal places.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Integer"
                },
                "units": {
                    "description": "Stringified units, expressed in UCUM unit syntax, e.g. \"kg/m2\", \u201cmm[Hg]\", \"ms-1\", \"km/h\". Implemented accordingly in subtypes.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                }
            },
            "required": [
                "magnitude",
                "units"
            ],
            "$inherits": [
                "#/definitions/DV_AMOUNT"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": null
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "valid_percentage": {
                    "description": "Test whether a number is a valid percentage, i.e. between 0 and 100. "
                },
                "infix =": {
                    "description": null
                },
                "infix +": {
                    "description": "Sum of this quantity and another whose formal type must be the difference type of this quantity. The value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* both operand accuracies are unknown_accuracy_value.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "infix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "prefix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss."
                },
                "is_integral": {
                    "description": "True if precision = 0, meaning that the magnitude is a whole number."
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Accuracy_is_percent_validity": {
                    "description": "accuracy = 0 implies not accuracy_is_percent"
                },
                "Accuracy_validity": {
                    "description": "accuracy_is_percent implies valid_percentage (accuracy)"
                }
            }
        },
        "DV_COUNT": {
            "title": "DV_COUNT",
            "description": "Countable quantities. Used for countable types such as pregnancies and steps (taken by a physiotherapy patient), number of cigarettes smoked in a day. \n\nMisuse: Not to be used for amounts of physical entities (which all have units).",
            "$comments": "Defined in Data_types IM, inherits from DV_AMOUNT",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL_of_DV_COUNT"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE_of_DV_COUNT"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Accuracy of measurement, expressed either as a half-range percent value (`_accuracy_is_percent_` = `True`) or a half-range quantity. A value of `0` means that accuracy is 100%, i.e. no error.\n\nA value of `_unknown_accuracy_value_` means that accuracy was not recorded.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "accuracy_is_percent": {
                    "description": "If `True`, indicates that when this object was created, accuracy was recorded as a percent value; if `False`, as an absolute quantity value.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                },
                "magnitude": {
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Integer64"
                }
            },
            "required": [
                "magnitude"
            ],
            "$inherits": [
                "#/definitions/DV_AMOUNT"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": null
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "valid_percentage": {
                    "description": "Test whether a number is a valid percentage, i.e. between 0 and 100. "
                },
                "infix =": {
                    "description": null
                },
                "infix +": {
                    "description": "Sum of this quantity and another whose formal type must be the difference type of this quantity. The value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* both operand accuracies are unknown_accuracy_value.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "infix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "prefix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss."
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Accuracy_is_percent_validity": {
                    "description": "accuracy = 0 implies not accuracy_is_percent"
                },
                "Accuracy_validity": {
                    "description": "accuracy_is_percent implies valid_percentage (accuracy)"
                }
            }
        },
        "DV_ABSOLUTE_QUANTITY": {
            "title": "DV_ABSOLUTE_QUANTITY",
            "description": "Abstract class defining the concept of quantified entities whose values are absolute with respect to an origin. Dates and Times are the main example.",
            "$comments": "Defined in Data_types IM, abstract, inherits from DV_QUANTIFIED",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "$ref": "#/definitions/DV_AMOUNT"
                }
            },
            "$inherits": [
                "#/definitions/DV_QUANTIFIED"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": null
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "diff": {
                    "description": "Difference of two quantities.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown."
                },
                "add": {
                    "description": "Addition of a differential amount to this quantity. \n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown."
                },
                "subtract": {
                    "description": "Result of subtracting a differential amount from this quantity.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown."
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                }
            }
        },
        "DV_DURATION": {
            "title": "DV_DURATION",
            "description": "Represents a period of time with respect to a notional point in time, which is not specified. A sign may be used to indicate the duration is  backwards  in time rather than forwards. \n\nNOTE: a deviation from ISO8601 is supported, allowing the  W' designator to be mixed with other designators. See assumed types section in the Support IM. \n\nUsed for recording the duration of something in the real world, particularly when there is a need a) to represent the duration in customary format, i.e. days, hours, minutes etc, and b) if it will be used in computational operations with date/time quantities, i.e. additions, subtractions etc. \n\nMisuse: Durations cannot be used to represent points in time, or intervals of time. ",
            "$comments": "Defined in Data_types IM, inherits from DV_AMOUNT, Iso8601_duration",
            "type": "object",
            "properties": {
                "value": {
                    "description": "ISO8601 duration string.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Accuracy of measurement, expressed either as a half-range percent value (`_accuracy_is_percent_` = `True`) or a half-range quantity. A value of `0` means that accuracy is 100%, i.e. no error.\n\nA value of `_unknown_accuracy_value_` means that accuracy was not recorded.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Real"
                },
                "accuracy_is_percent": {
                    "description": "If `True`, indicates that when this object was created, accuracy was recorded as a percent value; if `False`, as an absolute quantity value.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Boolean"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_AMOUNT",
                "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Iso8601_duration"
            ],
            "$functions": {
                "valid_year": {
                    "description": null
                },
                "valid_month": {
                    "description": null
                },
                "valid_day": {
                    "description": "True if d >= 1 and d <= days_in_month (m, y)"
                },
                "valid_hour": {
                    "description": "True if (h >= 0 and h < Hours_in_day) or (h = Hours_in_day and m = 0 and s = 0)"
                },
                "valid_minute": {
                    "description": "True if m >= 0 and m < Minutes_in_hour."
                },
                "valid_second": {
                    "description": "True if s >= 0 and s < Seconds_in_minute ."
                },
                "valid_fractional_second": {
                    "description": "True if fs >= 0.0 and fs < 1.0 ."
                },
                "valid_iso8601_date": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the complete form:\n\n* `YYYY-MM-DD` (extended, preferred) or one of the partial forms `YYYY-MM` or `YYYY`\n* `YYYYMMDD` (compact) or a partial variant `YYYYMM`.\n\nWhere:\n\n* `YYYY` is the string form of any positive number in the range `0000` - `9999` (zero-filled to four digits)\n* `MM` is `01` - `12` (zero-filled to two digits)\n* `DD` is `01` - `31` (zero-filled to two digits)\n\nThe combinations of `YYYY`, `MM`, `DD` numbers must be correct with respect to the Gregorian calendar."
                },
                "valid_iso8601_time": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the form:\n\n* `hh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `hhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `hh:mm` (extended)\n** `hhmm` or `hh` (compact)\n\nwith an additional optional timezone indicator of:\n\n* `Z` or`\u00b1hh[:mm]` (extended)  `\u00b1hh[mm]` (compact)\n\nWhere:\n\n* `hh` is \"00\" - \"23\" (0-filled to two digits)\n* `mm` is \"00\" - \"59\" (0-filled to two digits)\n* `ss` is \"00\" - \"60\" (0-filled to two digits)\n* `[(,|.)s+]` is an optional string consisting of a comma or decimal point followed by numeric string of 1 or more digits, representing a fractional second\n* `Z` is a literal meaning UTC (modern replacement for GMT), i.e. timezone `+0000`\n"
                },
                "valid_iso8601_date_time": {
                    "description": "String is a valid ISO 8601 date-time, i.e. takes the form:\n\n* `YYYY-MM-DDThh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `YYYYMMDDThhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `YYYY-MM-DDThh:mm` or `YYYY-MM-DDThh` (extended)\n** `YYYYMMDDThhmm` or `YYYYMMDDThh` (compact)"
                },
                "valid_iso8601_duration": {
                    "description": "String is a valid ISO 8601 duration, i.e. takes the form:\n\n* `P[nnY][nnM][nnW][nnD][T[nnH][nnM][nnS]]`\n\nWhere each nn represents a number of years, months, etc. nnW represents a number of 7-day weeks.\n\nNote: allowing the `W` designator in the same expression as other designators is an exception to the published standard, but necessary in clinical information (typically for representing pregnancy duration)."
                },
                "infix <": {
                    "description": null
                },
                "is_partial": {
                    "description": "Returns False."
                },
                "is_extended": {
                    "description": "Returns True."
                },
                "seconds": {
                    "description": "Number of seconds."
                },
                "fractional_seconds": {
                    "description": "Fractional seconds."
                },
                "is_decimal_sign_comma": {
                    "description": "True if this time has a decimal part indicated by ',' (comma) rather than '.' (period)."
                },
                "months": {
                    "description": "Number of months."
                },
                "years": {
                    "description": "Number of years of nominal 365-day length."
                },
                "weeks": {
                    "description": "Number of 7 day weeks."
                },
                "to_seconds": {
                    "description": "Total number of seconds equivalent (including fractional) of entire duration."
                },
                "minutes": {
                    "description": "Number of 60 second minutes."
                },
                "hours": {
                    "description": "Number of 60 minute hours."
                },
                "days": {
                    "description": "Number of 24 hour days."
                },
                "as_string": {
                    "description": "Return the duration string value."
                },
                "is_strictly_comparable_to": {
                    "description": null
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": null
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "valid_percentage": {
                    "description": "Test whether a number is a valid percentage, i.e. between 0 and 100. "
                },
                "infix =": {
                    "description": null
                },
                "infix +": {
                    "description": "Sum of this quantity and another whose formal type must be the difference type of this quantity. The value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* both operand accuracies are unknown_accuracy_value.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "infix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown.\n\nIf the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand."
                },
                "prefix -": {
                    "description": "Negated version of current object, such as used for representing a difference, e.g. a weight loss."
                }
            },
            "$invariants": {
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Years_valid": {
                    "description": "years >= 0"
                },
                "Months_valid": {
                    "description": "months >= 0"
                },
                "Weeks_valid": {
                    "description": "weeks >= 0"
                },
                "Days_valid": {
                    "description": "days >= 0"
                },
                "Hours_valid": {
                    "description": "hours >= 0"
                },
                "Minutes_valid": {
                    "description": "minutes >= 0"
                },
                "Seconds_valid": {
                    "description": "seconds >= 0"
                },
                "Fractional_second_valid": {
                    "description": "fractional_second >= 0.0 and fractional_second < 1.0"
                },
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Accuracy_is_percent_validity": {
                    "description": "accuracy = 0 implies not accuracy_is_percent"
                },
                "Accuracy_validity": {
                    "description": "accuracy_is_percent implies valid_percentage (accuracy)"
                },
                "Value_valid": {
                    "description": "valid_iso8601_duration (value)"
                }
            }
        },
        "DV_TEMPORAL": {
            "title": "DV_TEMPORAL",
            "description": "Specialised temporal variant of `DV_ABSOLUTE_QUANTITY` whose diff type is `DV_DURATION`. ",
            "$comments": "Defined in Data_types IM, abstract, inherits from DV_ABSOLUTE_QUANTITY",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Time accuracy, expressed as a duration.",
                    "$ref": "#/definitions/DV_DURATION"
                }
            },
            "$inherits": [
                "#/definitions/DV_ABSOLUTE_QUANTITY"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": null
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "diff": {
                    "description": "Difference of two quantities."
                },
                "add": {
                    "description": "Addition of a differential amount to this quantity. \n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown."
                },
                "subtract": {
                    "description": "Result of subtracting a differential amount from this quantity.\n\nThe value of accuracy in the result is either:\n\n* the sum of the accuracies of the operands, if both present, or;\n* unknown, if either or both operand accuracies are unknown."
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                }
            }
        },
        "DV_DATE": {
            "title": "DV_DATE",
            "description": "Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.\n",
            "$comments": "Defined in Data_types IM, inherits from DV_TEMPORAL, Iso8601_date",
            "type": "object",
            "properties": {
                "value": {
                    "description": "ISO8601 date string.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Time accuracy, expressed as a duration.",
                    "$ref": "#/definitions/DV_DURATION"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_TEMPORAL",
                "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Iso8601_date"
            ],
            "$functions": {
                "valid_year": {
                    "description": null
                },
                "valid_month": {
                    "description": null
                },
                "valid_day": {
                    "description": "True if d >= 1 and d <= days_in_month (m, y)"
                },
                "valid_hour": {
                    "description": "True if (h >= 0 and h < Hours_in_day) or (h = Hours_in_day and m = 0 and s = 0)"
                },
                "valid_minute": {
                    "description": "True if m >= 0 and m < Minutes_in_hour."
                },
                "valid_second": {
                    "description": "True if s >= 0 and s < Seconds_in_minute ."
                },
                "valid_fractional_second": {
                    "description": "True if fs >= 0.0 and fs < 1.0 ."
                },
                "valid_iso8601_date": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the complete form:\n\n* `YYYY-MM-DD` (extended, preferred) or one of the partial forms `YYYY-MM` or `YYYY`\n* `YYYYMMDD` (compact) or a partial variant `YYYYMM`.\n\nWhere:\n\n* `YYYY` is the string form of any positive number in the range `0000` - `9999` (zero-filled to four digits)\n* `MM` is `01` - `12` (zero-filled to two digits)\n* `DD` is `01` - `31` (zero-filled to two digits)\n\nThe combinations of `YYYY`, `MM`, `DD` numbers must be correct with respect to the Gregorian calendar."
                },
                "valid_iso8601_time": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the form:\n\n* `hh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `hhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `hh:mm` (extended)\n** `hhmm` or `hh` (compact)\n\nwith an additional optional timezone indicator of:\n\n* `Z` or`\u00b1hh[:mm]` (extended)  `\u00b1hh[mm]` (compact)\n\nWhere:\n\n* `hh` is \"00\" - \"23\" (0-filled to two digits)\n* `mm` is \"00\" - \"59\" (0-filled to two digits)\n* `ss` is \"00\" - \"60\" (0-filled to two digits)\n* `[(,|.)s+]` is an optional string consisting of a comma or decimal point followed by numeric string of 1 or more digits, representing a fractional second\n* `Z` is a literal meaning UTC (modern replacement for GMT), i.e. timezone `+0000`\n"
                },
                "valid_iso8601_date_time": {
                    "description": "String is a valid ISO 8601 date-time, i.e. takes the form:\n\n* `YYYY-MM-DDThh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `YYYYMMDDThhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `YYYY-MM-DDThh:mm` or `YYYY-MM-DDThh` (extended)\n** `YYYYMMDDThhmm` or `YYYYMMDDThh` (compact)"
                },
                "valid_iso8601_duration": {
                    "description": "String is a valid ISO 8601 duration, i.e. takes the form:\n\n* `P[nnY][nnM][nnW][nnD][T[nnH][nnM][nnS]]`\n\nWhere each nn represents a number of years, months, etc. nnW represents a number of 7-day weeks.\n\nNote: allowing the `W` designator in the same expression as other designators is an exception to the published standard, but necessary in clinical information (typically for representing pregnancy duration)."
                },
                "infix <": {
                    "description": "Tests if this date is earlier than the cited date."
                },
                "is_partial": {
                    "description": "True if this date is partial, i.e. if days or more is missing."
                },
                "is_extended": {
                    "description": "True if this date uses `'-'` separators."
                },
                "year": {
                    "description": "Year."
                },
                "month": {
                    "description": "Month in year."
                },
                "day": {
                    "description": "Day in month."
                },
                "timezone": {
                    "description": "Timezone; may be Void."
                },
                "month_unknown": {
                    "description": "Indicates whether month in year is unknown. If so, the date is of the form `\"YYYY\"`."
                },
                "day_unknown": {
                    "description": "Indicates whether day in month is unknown. If so, and month is known, the date is of the form `\"YYYY-MM\"` or `\"YYYYMM\"`."
                },
                "as_string": {
                    "description": "Return string value in extended format."
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": "Numeric value of the date as days since the calendar origin date `0001-01-01`."
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "diff": {
                    "description": "Difference of two quantities."
                },
                "add": {
                    "description": "Add a time period to this date."
                },
                "subtract": {
                    "description": "Subtract a time period from this date."
                }
            },
            "$invariants": {
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Year_valid": {
                    "description": "valid_year (year)"
                },
                "Month_valid": {
                    "description": "not month_unknown implies valid_month (month)"
                },
                "Day_valid": {
                    "description": "not day_unknown implies valid_day (year, month, day)"
                },
                "Partial_validity": {
                    "description": "month_unknown implies day_unknown"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Value_valid": {
                    "description": "valid_iso8601_date(value)"
                }
            }
        },
        "DV_TIME": {
            "title": "DV_TIME",
            "description": "Represents an absolute point in time from an origin usually interpreted as meaning the start of the current day, specified to a fraction of a second. Semantics defined by ISO 8601. \n\nUsed for recording real world times, rather than scientifically measured fine amounts of time. The partial form is used for approximate times of events and substance administrations. ",
            "$comments": "Defined in Data_types IM, inherits from DV_TEMPORAL, Iso8601_time",
            "type": "object",
            "properties": {
                "value": {
                    "description": "ISO8601 time string",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Time accuracy, expressed as a duration.",
                    "$ref": "#/definitions/DV_DURATION"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_TEMPORAL",
                "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Iso8601_time"
            ],
            "$functions": {
                "valid_year": {
                    "description": null
                },
                "valid_month": {
                    "description": null
                },
                "valid_day": {
                    "description": "True if d >= 1 and d <= days_in_month (m, y)"
                },
                "valid_hour": {
                    "description": "True if (h >= 0 and h < Hours_in_day) or (h = Hours_in_day and m = 0 and s = 0)"
                },
                "valid_minute": {
                    "description": "True if m >= 0 and m < Minutes_in_hour."
                },
                "valid_second": {
                    "description": "True if s >= 0 and s < Seconds_in_minute ."
                },
                "valid_fractional_second": {
                    "description": "True if fs >= 0.0 and fs < 1.0 ."
                },
                "valid_iso8601_date": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the complete form:\n\n* `YYYY-MM-DD` (extended, preferred) or one of the partial forms `YYYY-MM` or `YYYY`\n* `YYYYMMDD` (compact) or a partial variant `YYYYMM`.\n\nWhere:\n\n* `YYYY` is the string form of any positive number in the range `0000` - `9999` (zero-filled to four digits)\n* `MM` is `01` - `12` (zero-filled to two digits)\n* `DD` is `01` - `31` (zero-filled to two digits)\n\nThe combinations of `YYYY`, `MM`, `DD` numbers must be correct with respect to the Gregorian calendar."
                },
                "valid_iso8601_time": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the form:\n\n* `hh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `hhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `hh:mm` (extended)\n** `hhmm` or `hh` (compact)\n\nwith an additional optional timezone indicator of:\n\n* `Z` or`\u00b1hh[:mm]` (extended)  `\u00b1hh[mm]` (compact)\n\nWhere:\n\n* `hh` is \"00\" - \"23\" (0-filled to two digits)\n* `mm` is \"00\" - \"59\" (0-filled to two digits)\n* `ss` is \"00\" - \"60\" (0-filled to two digits)\n* `[(,|.)s+]` is an optional string consisting of a comma or decimal point followed by numeric string of 1 or more digits, representing a fractional second\n* `Z` is a literal meaning UTC (modern replacement for GMT), i.e. timezone `+0000`\n"
                },
                "valid_iso8601_date_time": {
                    "description": "String is a valid ISO 8601 date-time, i.e. takes the form:\n\n* `YYYY-MM-DDThh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `YYYYMMDDThhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `YYYY-MM-DDThh:mm` or `YYYY-MM-DDThh` (extended)\n** `YYYYMMDDThhmm` or `YYYYMMDDThh` (compact)"
                },
                "valid_iso8601_duration": {
                    "description": "String is a valid ISO 8601 duration, i.e. takes the form:\n\n* `P[nnY][nnM][nnW][nnD][T[nnH][nnM][nnS]]`\n\nWhere each nn represents a number of years, months, etc. nnW represents a number of 7-day weeks.\n\nNote: allowing the `W` designator in the same expression as other designators is an exception to the published standard, but necessary in clinical information (typically for representing pregnancy duration)."
                },
                "infix <": {
                    "description": null
                },
                "is_partial": {
                    "description": "True if this time is partial, i.e. if seconds or more is missing."
                },
                "is_extended": {
                    "description": "True if this time uses \u2018-\u2019, \u2018:\u2019 separators."
                },
                "hour": {
                    "description": "Hour in day, in 24-hour time."
                },
                "minute": {
                    "description": "Minute in hour."
                },
                "second": {
                    "description": "Second in minute."
                },
                "fractional_second": {
                    "description": "Fractional seconds."
                },
                "timezone": {
                    "description": "Timezone; may be Void."
                },
                "minute_unknown": {
                    "description": "Indicates whether minute is unknown. If so, the time is of the form \u201chh\u201d."
                },
                "second_unknown": {
                    "description": "Indicates whether second is unknown. If so and month is known, the time is of the form `\"hh:mm\"` or `\"hhmm\"`."
                },
                "is_decimal_sign_comma": {
                    "description": "True if this time has a decimal part indicated by \u2018,\u2019 (comma) rather than \u2018.\u2019 (period)."
                },
                "has_fractional_second": {
                    "description": "True if the fractional_second part is signficant (i.e. even if = 0.0)."
                },
                "as_string": {
                    "description": "Return string value in extended format."
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": "Numeric value of the time as seconds since the start of day, i.e. `00:00:00`. "
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "diff": {
                    "description": "Difference of two quantities."
                },
                "add": {
                    "description": "Add a time period to this time."
                },
                "subtract": {
                    "description": "Subtract a duration from this time."
                },
                "operator=": {
                    "description": null
                }
            },
            "$invariants": {
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Hour_valid": {
                    "description": "valid_hour(hour, minute, second)"
                },
                "Minute_valid": {
                    "description": "not minute_unknown implies valid_minute (minute)"
                },
                "Second_valid": {
                    "description": "not second_unknown implies valid_second (second)"
                },
                "Fractional_second_valid": {
                    "description": "has_fractional_second implies (not second_unknown and valid_fractional_second (fractional_second))"
                },
                "Partial_validity": {
                    "description": "minute_unknown implies second_unknown"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Value_valid": {
                    "description": "valid_iso8601_time (value)"
                }
            }
        },
        "DV_DATE_TIME": {
            "title": "DV_DATE_TIME",
            "description": "Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601. \n\nUsed for recording a precise point in real world time, and for approximate time stamps, e.g. the origin of a `HISTORY` in an `OBSERVATION` which is only partially known. \n",
            "$comments": "Defined in Data_types IM, inherits from DV_TEMPORAL, Iso8601_date_time",
            "type": "object",
            "properties": {
                "value": {
                    "description": "ISO8601 date/time string.",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "magnitude_status": {
                    "description": "Optional status of magnitude with values: \n\n* `\"=\"`   :   magnitude is a point value \n* `\"<\"`   :   value is < magnitude \n* `\">\"`   :   value is > magnitude \n* `\"<=\"` : value is <= magnitude \n* `\">=\"` : value is >= magnitude \n* `\"~\"`   :   value is approximately magnitude \n\nIf not present, assumed meaning is  `\"=\"` . \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                },
                "accuracy": {
                    "description": "Time accuracy, expressed as a duration.",
                    "$ref": "#/definitions/DV_DURATION"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_TEMPORAL",
                "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Iso8601_date_time"
            ],
            "$functions": {
                "valid_year": {
                    "description": null
                },
                "valid_month": {
                    "description": null
                },
                "valid_day": {
                    "description": "True if d >= 1 and d <= days_in_month (m, y)"
                },
                "valid_hour": {
                    "description": "True if (h >= 0 and h < Hours_in_day) or (h = Hours_in_day and m = 0 and s = 0)"
                },
                "valid_minute": {
                    "description": "True if m >= 0 and m < Minutes_in_hour."
                },
                "valid_second": {
                    "description": "True if s >= 0 and s < Seconds_in_minute ."
                },
                "valid_fractional_second": {
                    "description": "True if fs >= 0.0 and fs < 1.0 ."
                },
                "valid_iso8601_date": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the complete form:\n\n* `YYYY-MM-DD` (extended, preferred) or one of the partial forms `YYYY-MM` or `YYYY`\n* `YYYYMMDD` (compact) or a partial variant `YYYYMM`.\n\nWhere:\n\n* `YYYY` is the string form of any positive number in the range `0000` - `9999` (zero-filled to four digits)\n* `MM` is `01` - `12` (zero-filled to two digits)\n* `DD` is `01` - `31` (zero-filled to two digits)\n\nThe combinations of `YYYY`, `MM`, `DD` numbers must be correct with respect to the Gregorian calendar."
                },
                "valid_iso8601_time": {
                    "description": "String is a valid ISO 8601 date, i.e. takes the form:\n\n* `hh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `hhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `hh:mm` (extended)\n** `hhmm` or `hh` (compact)\n\nwith an additional optional timezone indicator of:\n\n* `Z` or`\u00b1hh[:mm]` (extended)  `\u00b1hh[mm]` (compact)\n\nWhere:\n\n* `hh` is \"00\" - \"23\" (0-filled to two digits)\n* `mm` is \"00\" - \"59\" (0-filled to two digits)\n* `ss` is \"00\" - \"60\" (0-filled to two digits)\n* `[(,|.)s+]` is an optional string consisting of a comma or decimal point followed by numeric string of 1 or more digits, representing a fractional second\n* `Z` is a literal meaning UTC (modern replacement for GMT), i.e. timezone `+0000`\n"
                },
                "valid_iso8601_date_time": {
                    "description": "String is a valid ISO 8601 date-time, i.e. takes the form:\n\n* `YYYY-MM-DDThh:mm:ss[(,|.)s+][Z|\u00b1hh[:mm]]` (extended)\n* `YYYYMMDDThhmmss[(,|.)s+][Z|\u00b1hh[mm]]` (compact)\n* or one of the partial forms:\n** `YYYY-MM-DDThh:mm` or `YYYY-MM-DDThh` (extended)\n** `YYYYMMDDThhmm` or `YYYYMMDDThh` (compact)"
                },
                "valid_iso8601_duration": {
                    "description": "String is a valid ISO 8601 duration, i.e. takes the form:\n\n* `P[nnY][nnM][nnW][nnD][T[nnH][nnM][nnS]]`\n\nWhere each nn represents a number of years, months, etc. nnW represents a number of 7-day weeks.\n\nNote: allowing the `W` designator in the same expression as other designators is an exception to the published standard, but necessary in clinical information (typically for representing pregnancy duration)."
                },
                "infix <": {
                    "description": null
                },
                "is_partial": {
                    "description": "True if this date time is partial, i.e. if seconds or more is missing."
                },
                "is_extended": {
                    "description": "True if this date/time uses \u2018-\u2019, \u2018:\u2019 separators."
                },
                "year": {
                    "description": "Year."
                },
                "month": {
                    "description": "Month in year."
                },
                "day": {
                    "description": "Day in month."
                },
                "hour": {
                    "description": "Hour in day."
                },
                "minute": {
                    "description": "Minute in hour."
                },
                "second": {
                    "description": "Second in minute."
                },
                "fractional_second": {
                    "description": "Fractional seconds."
                },
                "timezone": {
                    "description": "Timezone; may be Void."
                },
                "month_unknown": {
                    "description": "Indicates whether month in year is unknown."
                },
                "day_unknown": {
                    "description": "Indicates whether day in month is unknown."
                },
                "minute_unknown": {
                    "description": "Indicates whether minute in hour is known."
                },
                "second_unknown": {
                    "description": "Indicates whether minute in hour is known."
                },
                "is_decimal_sign_comma": {
                    "description": "True if this time has a decimal part indicated by \u2018,\u2019 (comma) rather than \u2018.\u2019 (period)."
                },
                "has_fractional_second": {
                    "description": "True if the fractional_second part is signficant (i.e. even if = 0.0)."
                },
                "as_string": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": "Test if two instances are strictly comparable."
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "valid_magnitude_status": {
                    "description": "Test whether a string value is one of the valid values for the magnitude_status attribute. "
                },
                "magnitude": {
                    "description": "Numeric value of the date/time as seconds since the calendar origin date/time `0001-01-01T00:00:00Z`. \n"
                },
                "accuracy_unknown": {
                    "description": "True if accuracy is not known, e.g. due to not being recorded or discernable."
                },
                "diff": {
                    "description": "Difference of two quantities."
                },
                "add": {
                    "description": "Add a time period to this date_time."
                },
                "subtract": {
                    "description": "Subtract a time period from this date_time."
                },
                "operator=": {
                    "description": null
                }
            },
            "$invariants": {
                "Post": {
                    "description": "Result = s.is_equal (\u201c=\u201d) or s.is_equal (\u201c<\u201d) or s.is_equal (\u201c>\u201d) or s.is_equal (\u201c<=\u201d) or s.is_equal (\u201c>=\u201d) or s.is_equal (\u201c~\u201d)"
                },
                "Year_valid": {
                    "description": "valid_year (year)"
                },
                "Month_valid": {
                    "description": "valid_month (month)"
                },
                "Day_valid": {
                    "description": "valid_day(year, month, day)"
                },
                "Hour_valid": {
                    "description": "valid_hour (hour, minute, second)"
                },
                "Minute_valid": {
                    "description": "not minute_unknown implies valid_minute(minute)"
                },
                "Second_valid": {
                    "description": "not second_unknown implies valid_second (second)"
                },
                "Fractional_second_valid": {
                    "description": "has_fractional_second implies (not second_unknown and valid_fractional_second (fractional_second))"
                },
                "Partial_validity_year": {
                    "description": "not month_unknown"
                },
                "Partial_validity_month": {
                    "description": "not month_unknown"
                },
                "Partial_validity_day": {
                    "description": "not day_unknown"
                },
                "Partial_validity_hour": {
                    "description": "not hour_unknown"
                },
                "Partial_validity_minute": {
                    "description": "minute_unknown implies second_unknown"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Magnitude_status_valid": {
                    "description": "magnitude_status /= Void implies valid_magnitude_status (magnitude_status)"
                },
                "Value_valid": {
                    "description": "valid_iso8601_date_time (value)"
                }
            }
        },
        "DV_ORDINAL": {
            "title": "DV_ORDINAL",
            "description": "Models rankings and scores, e.g. pain, Apgar values, etc, where there is \n\na) implied ordering, \nb) no implication that the distance between each value is constant, and \nc) the total number of values is finite. \n\nNote that although the term  ordinal' in mathematics means natural numbers only, here any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point. Examples of sets of ordinal values: \n\n*   -3, -2, -1, 0, 1, 2, 3  -- reflex response values \n*    0, 1, 2                  -- Apgar values \n\nThis class is used for recording any clinical datum which is customarily recorded using symbolic values. Example: the results on a urinalysis strip, e.g. `{neg, trace, +, ++, +++}` are used for leucocytes, protein, nitrites etc; for non-haemolysed blood `{neg, trace, moderate}`; for haemolysed blood `{small, moderate, large}`. ",
            "$comments": "Defined in Data_types IM, inherits from DV_ORDERED",
            "type": "object",
            "properties": {
                "normal_status": {
                    "description": "Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  `normal_status`. ",
                    "$ref": "#/definitions/CODE_PHRASE"
                },
                "normal_range": {
                    "description": "Optional normal range. ",
                    "$ref": "#/definitions/DV_INTERVAL"
                },
                "other_reference_ranges": {
                    "description": "Optional tagged other reference ranges for this value in its particular measurement context.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/REFERENCE_RANGE"
                    }
                },
                "symbol": {
                    "description": "Coded textual representation of this value in the enumeration, which may be strings made from  +  symbols, or other enumerations of terms such as  mild ,  moderate ,  severe , or even the same number series as the values, e.g.  1 ,  2 ,  3 . Codes come from archetype. ",
                    "$ref": "#/definitions/DV_CODED_TEXT"
                },
                "value": {
                    "description": "Value in ordered enumeration of values. Any integer value can be used. \n",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/Integer"
                }
            },
            "required": [
                "symbol",
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_ORDERED"
            ],
            "$functions": {
                "infix <": {
                    "description": null
                },
                "is_strictly_comparable_to": {
                    "description": null
                },
                "is_simple": {
                    "description": "True if this quantity has no reference ranges."
                },
                "is_normal": {
                    "description": "Value is in the normal range, determined by comparison of the value to the normal_range if present, or by the normal_status marker if present. \n"
                },
                "limits": {
                    "description": "\nLimits of the ordinal enumeration, to allow comparison of an ordinal \nvalue to its limits. \n"
                },
                "<": {
                    "description": null
                }
            },
            "$invariants": {
                "Other_reference_ranges_validity": {
                    "description": "other_reference_ranges /= Void implies not other_reference_ranges.is_empty"
                },
                "Is_simple_validity": {
                    "description": "(normal_range = Void and other_reference_ranges = Void) implies is_simple"
                },
                "Normal_status_validity": {
                    "description": "normal_status /= Void implies code_set (Code_set_id_normal_statuses).has_code (normal_status)"
                },
                "Normal_range_and_status_consistency": {
                    "description": "(normal_range /= Void and normal_status /= Void) implies (normal_status.code_string.is_equal (\u201cN\u201d) xor not normal_range.has (self))"
                },
                "Pre": {
                    "description": "normal_range /= Void or normal_status /= Void"
                },
                "Post_range": {
                    "description": "normal_range /= Void implies Result = normal_range.has (self)"
                },
                "Post_status": {
                    "description": "normal_status /= Void implies normal_status.code_string.is_equal (\u201cN\u201d)"
                },
                "Limits_valid": {
                    "description": "limits.meaning.is_equal (\u201climits\u201d)"
                },
                "Reference_range_valid": {
                    "description": "other_reference_ranges.has (limits)"
                },
                "Post": {
                    "description": "Result = value < other.value"
                }
            }
        },
        "DV_INTERVAL_of_DV_DATE_TIME": {
            "title": "DV_INTERVAL<DV_DATE_TIME>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "DV_INTERVAL_of_DV_DATE": {
            "title": "DV_INTERVAL<DV_DATE>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "DV_INTERVAL_of_DV_QUANTITY": {
            "title": "DV_INTERVAL<DV_QUANTITY>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "DV_INTERVAL<DV_COUNT>": {
            "title": "DV_INTERVAL<DV_COUNT>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "DV_INTERVAL<DV_PROPORTION>": {
            "title": "DV_INTERVAL<DV_PROPORTION>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "REFERENCE_RANGE<DV_QUANTITY>": {
            "title": "REFERENCE_RANGE<DV_QUANTITY>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "REFERENCE_RANGE<DV_COUNT>": {
            "title": "REFERENCE_RANGE<DV_COUNT>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "REFERENCE_RANGE<DV_PROPORTION>": {
            "title": "REFERENCE_RANGE<DV_PROPORTION>",
            "$comments": "Defined in Data_types IM",
            "type": "object"
        },
        "DV_TIME_SPECIFICATION": {
            "title": "DV_TIME_SPECIFICATION",
            "description": "This is an abstract class of which all timing specifications are specialisations. Specifies points in time, possibly linked to the calendar, or a real world repeating event, such as  breakfast. ",
            "$comments": "Defined in Data_types IM, abstract, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "value": {
                    "description": "The specification, in the HL7v3 syntax for `PIVL` or `EIVL` types.",
                    "$ref": "#/definitions/DV_PARSABLE"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ],
            "$functions": {
                "calendar_alignment": {
                    "description": "Indicates what prototypical point in the calendar the specification is aligned to, e.g.  5th of the month . Empty if not aligned. Extracted from the  value' attribute."
                },
                "event_alignment": {
                    "description": "Indicates what real-world event the specification is aligned to if any. Extracted from the  value' attribute. "
                },
                "institution_specified": {
                    "description": "Indicates if the specification is aligned with institution schedules, e.g. a hospital nursing changeover or meal serving times. Extracted from the  value' attribute."
                }
            }
        },
        "DV_PERIODIC_TIME_SPECIFICATION": {
            "title": "DV_PERIODIC_TIME_SPECIFICATION",
            "description": "Specifies periodic points in time, linked to the calendar (phase-linked), or a real world repeating event, such as  breakfast  (event-linked). Based on the HL7v3 data types `PIVL<T>` and `EIVL<T>`. \n\nUsed in therapeutic prescriptions, expressed as `INSTRUCTIONs` in the openEHR model. ",
            "$comments": "Defined in Data_types IM, inherits from DV_TIME_SPECIFICATION",
            "type": "object",
            "properties": {
                "value": {
                    "description": "The specification, in the HL7v3 syntax for `PIVL` or `EIVL` types.",
                    "$ref": "#/definitions/DV_PARSABLE"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_TIME_SPECIFICATION"
            ],
            "$functions": {
                "calendar_alignment": {
                    "description": "Calendar alignment extracted from value. "
                },
                "event_alignment": {
                    "description": "Event alignment extracted from value. "
                },
                "institution_specified": {
                    "description": "Extracted from value."
                },
                "period": {
                    "description": "The period of the repetition, computationally derived from the syntax representation. Extracted from the  value' attribute."
                }
            },
            "$invariants": {
                "Value_valid": {
                    "description": "value.formalism.is_equal (\u201cHL7:PIVL\u201d) or value.formalism. is_equal (\u201cHL7:EIVL\u201d)"
                }
            }
        },
        "DV_GENERAL_TIME_SPECIFICATION": {
            "title": "DV_GENERAL_TIME_SPECIFICATION",
            "description": "Specifies points in time in a general syntax. Based on the HL7v3 GTS data type.",
            "$comments": "Defined in Data_types IM, inherits from DV_TIME_SPECIFICATION",
            "type": "object",
            "properties": {
                "value": {
                    "description": "The specification, in the HL7v3 syntax for `PIVL` or `EIVL` types.",
                    "$ref": "#/definitions/DV_PARSABLE"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_TIME_SPECIFICATION"
            ],
            "$functions": {
                "calendar_alignment": {
                    "description": "Calendar alignment extracted from value."
                },
                "event_alignment": {
                    "description": "Event alignment extracted from value. "
                },
                "institution_specified": {
                    "description": "Extracted from value."
                }
            }
        },
        "DV_URI": {
            "title": "DV_URI",
            "description": "A reference to an object which conforms to the Universal Resource Identifier (URI) standard. See \"Universal Resource Identifiers in WWW\" by Tim Berners-Lee at http://www.ietf.org/rfc/rfc3986.txt. This  is  a  World-Wide  Web  RFC for  global identification  of resources. \nSee http://www.w3.org/Addressing for a starting point on URIs. \n",
            "$comments": "Defined in Data_types IM, inherits from DATA_VALUE",
            "type": "object",
            "properties": {
                "value": {
                    "description": "Value of URI as a String. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DATA_VALUE"
            ],
            "$functions": {
                "scheme": {
                    "description": "A distributed information \"space\" in which  information objects  exist. The scheme simultaneously specifies an information space and a mechanism for accessing objects in  that  space.  For  example  if  scheme  = \"ftp\", it identifies the information space in which  all  ftpable objects  exist,  and also the application - ftp - which can be used to access them. Values may include: \"ftp\", \"telnet\", \"mailto\", \"gopher\" and  many others. Refer to WWW URI RFC for a full list. New information spaces can be accommodated  within  the URI specification. \n"
                },
                "path": {
                    "description": "A string whose format is  a  function  of  the  scheme. Identifies   the   location  in  <scheme>-space  of  an information entity. Typical values include hierarchical directory  paths  for  any  machine.  For example, with scheme = \"ftp\", path might be /pub/images/image_01. The strings \".\" and \"..\" are reserved for use in the path. Paths may include internet/intranet location identifiers of the form: sub_domain...domain, e.g. \"info.cern.ch\" "
                },
                "fragment_id": {
                    "description": "A part of, a  fragment  or  a  sub-function  within  an object. Allows references to sub-parts of objects, such as a certain line and character  position  in  a  text object. The  syntax  and semantics are defined by the application responsible for the object. \n"
                },
                "query": {
                    "description": "Query string to send to application implied  by  scheme and  path.  Enables  queries  to applications, including databases  to  be  included in  the  URI. Supports any query meaningful to the server, including SQL. \n"
                }
            },
            "$invariants": {
                "Value_valid": {
                    "description": "not value.is_empty"
                }
            }
        },
        "DV_EHR_URI": {
            "title": "DV_EHR_URI",
            "description": "A `DV_EHR_URI` is a `DV_URI` which has the scheme name 'ehr', and which can only reference items in EHRs. \n\nUsed to reference items in an EHR, which may be the same as the current EHR (containing this link), or another.",
            "$comments": "Defined in Data_types IM, inherits from DV_URI",
            "type": "object",
            "properties": {
                "value": {
                    "description": "Value of URI as a String. ",
                    "$ref": "https://www.openEHR.org/releases/ITS-JSON/Release-1.0.0/BASE/latest/Foundation_types/all.json#/definitions/String"
                }
            },
            "required": [
                "value"
            ],
            "$inherits": [
                "#/definitions/DV_URI"
            ],
            "$functions": {
                "scheme": {
                    "description": "A distributed information \"space\" in which  information objects  exist. The scheme simultaneously specifies an information space and a mechanism for accessing objects in  that  space.  For  example  if  scheme  = \"ftp\", it identifies the information space in which  all  ftpable objects  exist,  and also the application - ftp - which can be used to access them. Values may include: \"ftp\", \"telnet\", \"mailto\", \"gopher\" and  many others. Refer to WWW URI RFC for a full list. New information spaces can be accommodated  within  the URI specification. \n"
                },
                "path": {
                    "description": "A string whose format is  a  function  of  the  scheme. Identifies   the   location  in  <scheme>-space  of  an information entity. Typical values include hierarchical directory  paths  for  any  machine.  For example, with scheme = \"ftp\", path might be /pub/images/image_01. The strings \".\" and \"..\" are reserved for use in the path. Paths may include internet/intranet location identifiers of the form: sub_domain...domain, e.g. \"info.cern.ch\" "
                },
                "fragment_id": {
                    "description": "A part of, a  fragment  or  a  sub-function  within  an object. Allows references to sub-parts of objects, such as a certain line and character  position  in  a  text object. The  syntax  and semantics are defined by the application responsible for the object. \n"
                },
                "query": {
                    "description": "Query string to send to application implied  by  scheme and  path.  Enables  queries  to applications, including databases  to  be  included in  the  URI. Supports any query meaningful to the server, including SQL. \n"
                }
            },
            "$invariants": {
                "Value_valid": {
                    "description": "not value.is_empty"
                },
                "Scheme_valid": {
                    "description": "scheme.is_equal (Ehr_scheme)"
                }
            }
        }
    }
}